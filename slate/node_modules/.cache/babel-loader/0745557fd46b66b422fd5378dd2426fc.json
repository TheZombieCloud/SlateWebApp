{"ast":null,"code":"/*\n * Trianglify.js\n * by @qrohlf\n *\n * Licensed under the GPLv3\n */\nvar delaunay = require('delaunay-fast');\n\nvar seedrandom = require('seedrandom');\n\nvar chroma = require('chroma-js'); //PROBLEM: chroma.js is nearly 32k in size\n\n\nvar colorbrewer = require('./colorbrewer'); //We could use the chroma.js colorbrewer, but it's got some ugly stuff so we use our own subset.\n\n\nvar Pattern = require('./pattern');\n\nvar defaults = {\n  width: 600,\n  // Width of pattern\n  height: 400,\n  // Height of pattern\n  cell_size: 75,\n  // Size of the cells used to generate a randomized grid\n  variance: 0.75,\n  // how much to randomize the grid\n  seed: null,\n  // Seed for the RNG\n  x_colors: 'random',\n  // X color stops\n  y_colors: 'match_x',\n  // Y color stops\n  palette: colorbrewer,\n  // Palette to use for 'random' color option\n  color_space: 'lab',\n  // Color space used for gradient construction & interpolation\n  color_function: null,\n  // Color function f(x, y) that returns a color specification that is consumable by chroma-js\n  stroke_width: 1.51 // Width of stroke. Defaults to 1.51 to fix an issue with canvas antialiasing.\n\n};\n/*********************************************************\n*\n* Main function that is exported to the global namespace\n*\n**********************************************************/\n\nfunction Trianglify(opts) {\n  // apply defaults\n  opts = _merge_opts(defaults, opts); // setup seedable RNG\n\n  rand = seedrandom(opts.seed); // randomize colors if requested\n\n  if (opts.x_colors === 'random') opts.x_colors = _random_from_palette();\n  if (opts.y_colors === 'random') opts.y_colors = _random_from_palette();\n  if (opts.y_colors === 'match_x') opts.y_colors = opts.x_colors; // some sanity-checking\n\n  if (!(opts.width > 0 && opts.height > 0)) {\n    throw new Error(\"Width and height must be numbers greater than 0\");\n  }\n\n  if (opts.cell_size < 2) {\n    throw new Error(\"Cell size must be greater than 2.\");\n  } // Setup the color gradient function\n\n\n  var gradient;\n\n  if (opts.color_function) {\n    gradient = function (x, y) {\n      return chroma(opts.color_function(x, y));\n    };\n  } else {\n    var x_color = chroma.scale(opts.x_colors).mode(opts.color_space);\n    var y_color = chroma.scale(opts.y_colors).mode(opts.color_space);\n\n    gradient = function (x, y) {\n      return chroma.interpolate(x_color(x), y_color(y), 0.5, opts.color_space);\n    };\n  } // Figure out key dimensions\n  // it's a pain to prefix width and height with opts all the time, so let's\n  // give them proper variables to refer to\n\n\n  var width = opts.width;\n  var height = opts.height; // How many cells we're going to have on each axis (pad by 2 cells on each edge)\n\n  var cells_x = Math.floor((width + 4 * opts.cell_size) / opts.cell_size);\n  var cells_y = Math.floor((height + 4 * opts.cell_size) / opts.cell_size); // figure out the bleed widths to center the grid\n\n  var bleed_x = (cells_x * opts.cell_size - width) / 2;\n  var bleed_y = (cells_y * opts.cell_size - height) / 2; // how much can out points wiggle (+/-) given the cell padding?\n\n  var variance = opts.cell_size * opts.variance / 2; // Set up normalizers\n\n  var norm_x = function (x) {\n    return _map(x, [-bleed_x, width + bleed_x], [0, 1]);\n  };\n\n  var norm_y = function (y) {\n    return _map(y, [-bleed_y, height + bleed_y], [0, 1]);\n  }; // generate a point mesh\n\n\n  var points = _generate_points(width, height); // delaunay.triangulate gives us indices into the original coordinate array\n\n\n  var geom_indices = delaunay.triangulate(points); // iterate over the indices in groups of three to flatten them into polygons, with color lookup\n\n  var triangles = [];\n\n  var lookup_point = function (i) {\n    return points[i];\n  };\n\n  for (var i = 0; i < geom_indices.length; i += 3) {\n    var vertices = [geom_indices[i], geom_indices[i + 1], geom_indices[i + 2]].map(lookup_point);\n\n    var centroid = _centroid(vertices);\n\n    var color = gradient(norm_x(centroid.x), norm_y(centroid.y)).hex();\n    triangles.push([color, vertices]);\n  }\n\n  return Pattern(triangles, opts);\n  /*********************************************************\n  *\n  * Private functions\n  *\n  **********************************************************/\n\n  function _map(num, in_range, out_range) {\n    return (num - in_range[0]) * (out_range[1] - out_range[0]) / (in_range[1] - in_range[0]) + out_range[0];\n  } // generate points on a randomized grid\n\n\n  function _generate_points(width, height) {\n    var points = [];\n\n    for (var i = -bleed_x; i < width + bleed_x; i += opts.cell_size) {\n      for (var j = -bleed_y; j < height + bleed_y; j += opts.cell_size) {\n        var x = i + opts.cell_size / 2 + _map(rand(), [0, 1], [-variance, variance]);\n\n        var y = j + opts.cell_size / 2 + _map(rand(), [0, 1], [-variance, variance]);\n\n        points.push([x, y].map(Math.floor));\n      }\n    }\n\n    return points;\n  } //triangles only!\n\n\n  function _centroid(d) {\n    return {\n      x: (d[0][0] + d[1][0] + d[2][0]) / 3,\n      y: (d[0][1] + d[1][1] + d[2][1]) / 3\n    };\n  } // select a random palette from colorbrewer\n\n\n  function _random_from_palette() {\n    if (opts.palette instanceof Array) {\n      return opts.palette[Math.floor(rand() * opts.palette.length)];\n    }\n\n    var keys = Object.keys(opts.palette);\n    return opts.palette[keys[Math.floor(rand() * keys.length)]];\n  } // shallow extend (sort of) for option defaults\n\n\n  function _merge_opts(defaults, options) {\n    var out = {}; // shallow-copy defaults so we don't mutate the input objects (bad)\n\n    for (var key in defaults) {\n      out[key] = defaults[key];\n    }\n\n    for (key in options) {\n      if (defaults.hasOwnProperty(key)) {\n        out[key] = options[key]; // override defaults with options\n      } else {\n        throw new Error(key + \" is not a configuration option for Trianglify. Check your spelling?\");\n      }\n    }\n\n    return out;\n  }\n} //end of Trianglify function closure\n// exports\n\n\nTrianglify.colorbrewer = colorbrewer;\nTrianglify.defaults = defaults;\nmodule.exports = Trianglify;","map":null,"metadata":{},"sourceType":"script"}