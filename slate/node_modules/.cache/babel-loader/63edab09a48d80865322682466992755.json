{"ast":null,"code":"var Delaunay;\n\n(function () {\n  \"use strict\";\n\n  var EPSILON = 1.0 / 1048576.0;\n\n  function supertriangle(vertices) {\n    var xmin = Number.POSITIVE_INFINITY,\n        ymin = Number.POSITIVE_INFINITY,\n        xmax = Number.NEGATIVE_INFINITY,\n        ymax = Number.NEGATIVE_INFINITY,\n        i,\n        dx,\n        dy,\n        dmax,\n        xmid,\n        ymid;\n\n    for (i = vertices.length; i--;) {\n      if (vertices[i][0] < xmin) xmin = vertices[i][0];\n      if (vertices[i][0] > xmax) xmax = vertices[i][0];\n      if (vertices[i][1] < ymin) ymin = vertices[i][1];\n      if (vertices[i][1] > ymax) ymax = vertices[i][1];\n    }\n\n    dx = xmax - xmin;\n    dy = ymax - ymin;\n    dmax = Math.max(dx, dy);\n    xmid = xmin + dx * 0.5;\n    ymid = ymin + dy * 0.5;\n    return [[xmid - 20 * dmax, ymid - dmax], [xmid, ymid + 20 * dmax], [xmid + 20 * dmax, ymid - dmax]];\n  }\n\n  function circumcircle(vertices, i, j, k) {\n    var x1 = vertices[i][0],\n        y1 = vertices[i][1],\n        x2 = vertices[j][0],\n        y2 = vertices[j][1],\n        x3 = vertices[k][0],\n        y3 = vertices[k][1],\n        fabsy1y2 = Math.abs(y1 - y2),\n        fabsy2y3 = Math.abs(y2 - y3),\n        xc,\n        yc,\n        m1,\n        m2,\n        mx1,\n        mx2,\n        my1,\n        my2,\n        dx,\n        dy;\n    /* Check for coincident points */\n\n    if (fabsy1y2 < EPSILON && fabsy2y3 < EPSILON) throw new Error(\"Eek! Coincident points!\");\n\n    if (fabsy1y2 < EPSILON) {\n      m2 = -((x3 - x2) / (y3 - y2));\n      mx2 = (x2 + x3) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc = (x2 + x1) / 2.0;\n      yc = m2 * (xc - mx2) + my2;\n    } else if (fabsy2y3 < EPSILON) {\n      m1 = -((x2 - x1) / (y2 - y1));\n      mx1 = (x1 + x2) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      xc = (x3 + x2) / 2.0;\n      yc = m1 * (xc - mx1) + my1;\n    } else {\n      m1 = -((x2 - x1) / (y2 - y1));\n      m2 = -((x3 - x2) / (y3 - y2));\n      mx1 = (x1 + x2) / 2.0;\n      mx2 = (x2 + x3) / 2.0;\n      my1 = (y1 + y2) / 2.0;\n      my2 = (y2 + y3) / 2.0;\n      xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);\n      yc = fabsy1y2 > fabsy2y3 ? m1 * (xc - mx1) + my1 : m2 * (xc - mx2) + my2;\n    }\n\n    dx = x2 - xc;\n    dy = y2 - yc;\n    return {\n      i: i,\n      j: j,\n      k: k,\n      x: xc,\n      y: yc,\n      r: dx * dx + dy * dy\n    };\n  }\n\n  function dedup(edges) {\n    var i, j, a, b, m, n;\n\n    for (j = edges.length; j;) {\n      b = edges[--j];\n      a = edges[--j];\n\n      for (i = j; i;) {\n        n = edges[--i];\n        m = edges[--i];\n\n        if (a === m && b === n || a === n && b === m) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n  }\n\n  Delaunay = {\n    triangulate: function (vertices, key) {\n      var n = vertices.length,\n          i,\n          j,\n          indices,\n          st,\n          open,\n          closed,\n          edges,\n          dx,\n          dy,\n          a,\n          b,\n          c;\n      /* Bail if there aren't enough vertices to form any triangles. */\n\n      if (n < 3) return [];\n      /* Slice out the actual vertices from the passed objects. (Duplicate the\n       * array even if we don't, though, since we need to make a supertriangle\n       * later on!) */\n\n      vertices = vertices.slice(0);\n      if (key) for (i = n; i--;) vertices[i] = vertices[i][key];\n      /* Make an array of indices into the vertex array, sorted by the\n       * vertices' x-position. */\n\n      indices = new Array(n);\n\n      for (i = n; i--;) indices[i] = i;\n\n      indices.sort(function (i, j) {\n        return vertices[j][0] - vertices[i][0];\n      });\n      /* Next, find the vertices of the supertriangle (which contains all other\n       * triangles), and append them onto the end of a (copy of) the vertex\n       * array. */\n\n      st = supertriangle(vertices);\n      vertices.push(st[0], st[1], st[2]);\n      /* Initialize the open list (containing the supertriangle and nothing\n       * else) and the closed list (which is empty since we havn't processed\n       * any triangles yet). */\n\n      open = [circumcircle(vertices, n + 0, n + 1, n + 2)];\n      closed = [];\n      edges = [];\n      /* Incrementally add each vertex to the mesh. */\n\n      for (i = indices.length; i--; edges.length = 0) {\n        c = indices[i];\n        /* For each open triangle, check to see if the current point is\n         * inside it's circumcircle. If it is, remove the triangle and add\n         * it's edges to an edge list. */\n\n        for (j = open.length; j--;) {\n          /* If this point is to the right of this triangle's circumcircle,\n           * then this triangle should never get checked again. Remove it\n           * from the open list, add it to the closed list, and skip. */\n          dx = vertices[c][0] - open[j].x;\n\n          if (dx > 0.0 && dx * dx > open[j].r) {\n            closed.push(open[j]);\n            open.splice(j, 1);\n            continue;\n          }\n          /* If we're outside the circumcircle, skip this triangle. */\n\n\n          dy = vertices[c][1] - open[j].y;\n          if (dx * dx + dy * dy - open[j].r > EPSILON) continue;\n          /* Remove the triangle and add it's edges to the edge list. */\n\n          edges.push(open[j].i, open[j].j, open[j].j, open[j].k, open[j].k, open[j].i);\n          open.splice(j, 1);\n        }\n        /* Remove any doubled edges. */\n\n\n        dedup(edges);\n        /* Add a new triangle for each edge. */\n\n        for (j = edges.length; j;) {\n          b = edges[--j];\n          a = edges[--j];\n          open.push(circumcircle(vertices, a, b, c));\n        }\n      }\n      /* Copy any remaining open triangles to the closed list, and then\n       * remove any triangles that share a vertex with the supertriangle,\n       * building a list of triplets that represent triangles. */\n\n\n      for (i = open.length; i--;) closed.push(open[i]);\n\n      open.length = 0;\n\n      for (i = closed.length; i--;) if (closed[i].i < n && closed[i].j < n && closed[i].k < n) open.push(closed[i].i, closed[i].j, closed[i].k);\n      /* Yay, we're done! */\n\n\n      return open;\n    },\n    contains: function (tri, p) {\n      /* Bounding box test first, for quick rejections. */\n      if (p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0] || p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0] || p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1] || p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1]) return null;\n      var a = tri[1][0] - tri[0][0],\n          b = tri[2][0] - tri[0][0],\n          c = tri[1][1] - tri[0][1],\n          d = tri[2][1] - tri[0][1],\n          i = a * d - b * c;\n      /* Degenerate tri. */\n\n      if (i === 0.0) return null;\n      var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,\n          v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;\n      /* If we're outside the tri, fail. */\n\n      if (u < 0.0 || v < 0.0 || u + v > 1.0) return null;\n      return [u, v];\n    }\n  };\n  if (typeof module !== \"undefined\") module.exports = Delaunay;\n})();","map":null,"metadata":{},"sourceType":"script"}